[{"content":"hugo + gitaction 搭建自动化部署 hugo + gitaction 搭建自动化部署\nhugo + gitaction 搭建自动化部署\nhugo + gitaction 搭建自动化部署\nhugo + gitaction 搭建自动化部署\nhugo + gitaction 搭建自动化部署\n​​\n","date":"2024-11-25T01:01:26+08:00","permalink":"https://blazarix.github.io./post/hugo-gitaction-builds-automated-deployment-1dj9vd.html","title":"hugo + gitaction 搭建自动化部署"},{"content":"认知觉醒精读 所以，更多的时候你需要把它当成一本工具书，时常回顾、思考和实践，直到己发生真正的变化，而不是一读了之、过过“脑瘾” 。\n自序 开启自我改变的原动力 如果不出意外，大多数人都会沿着“求学—工作—婚恋”的路线成长，随着生活的惯性一直往前走。年轻的时候，几乎没有人会觉得自己的将来能有多差，认定美好的生活会自然到来。不谙世事的我们认为：即使暂时说不清具体该怎么做，但有份十足的信心就够了，毕竟年轻无敌嘛！然而现实并不总像我们想象的那样。在这份十足的信心陪伴多年之后，大多数人发现自己并没有变得特别，而是在不断地服从社会规则和应对生活烦恼，开始随波逐流：该玩手机玩手机、该打游戏打游戏；没有多少压力，也没有多少动力；觉得反正日子还过得去，希望也还在心里，偶尔挣扎呐喊一声，而后继续做着短视的选择，沉溺于眼前的安逸。 他们对这个世界的运行规则浑然不知：不知道事物的构成、框架，不知道努力的路径、方法，也不知道自己真正想要什么、能做什么、最后会成为什么样的人……\n这不就是我吗，一直做着短视的选择。高考时为了想快点玩，不想承受高考的压力，没有选择复读。进了一个普普通通的二本，在大学浑浑噩噩的过了四年，打了四年游戏。但是我又没有完全堕落，又保留着一丝清醒，随波逐流。参加工作了，一腔热血，最后还是沉溺于公司的安逸，一年经验也没成长多少。我总是间歇性努力，玩也玩不尽性，学也学不明白，干啥都是普普通通的，打游戏也打不明白。想努力又不只从何做起，看了这么多书，对我的生活还是一成不变。到底是为什么，是什么原因导致我控制不了自己？重新读这本书，精读，想重新改变自己的生活方式了。\n想勤奋，却总是敌不过惰性；想努力，却总是陷入低效的状态；想精进，面前却总是弯路不断；读了很多书，都忘了；付出很多努力，都白费了。他们仿佛越使劲越困惑，越努力越迷茫。这就是“醒着的睡着的人” 的画像，事实上也是我曾经的画像。\n在很长一段时间内，我就像一个没有睡醒的人，对自己不了解，对生活没主张，对命运无选择。那时的我，虽然对本职工作非常投入，但业余时间几乎被不需要动脑筋的事情占据：有空就找朋友们聚会，时常喝到烂醉；经常熬夜，从不主动看书、运动；打发时间的方式就是看搞笑视频、读八卦新闻、玩手机游戏；实在没事可做，就裹起被子睡大觉……下意识中，我觉得这种无忧的生活会继续下去\n每一字每一句说的都是我！！重读还是想新读一样\n我发现每天有事情做不代表觉醒，每天都努力也不代表觉醒，真正的觉醒是一种发自内心的渴望，立足长远，保持耐心，运用认知的力量与时间做朋友；我发现人与人之间的根本差异是认知能力上的差异，因为认知影响选择，而选择改变命运，所以成长的本质就是让大脑的认知变得更加清晰；\n说白了，就是信息差。你了解的信息越多，越能对局面作出正确的判断，自己做出正确的选择。就像瓦罗兰特一样，获取的信息越多，越可能做出最正确的选择，而正确的选择决定了这一局的输赢。人生也是一样，要尽可能多的获取更多的信息来帮助我们选择，但是知识是无穷无尽的，这一辈子也学不完。所以应该学习那些具有普适性的知识，也就是最底层的知识，然后根据这些知识来推演当前的情况。这些底层的知识，我认为就是元认知，也是作者后面提到的。\n‍\n焦虑的根源 归结起来，焦虑的原因就两条：想同时做很多事，又想立即看到效果。王小波说：人的一切痛苦，本质上都是对自己无能的愤怒。焦虑的本质也契合这一观点：自己的欲望大于能力，又极度缺乏耐心。焦虑就是因为欲望与能力之间差\n想起金木的一句话，一切的痛苦，都是自身能力的不足导致的！\n焦虑并不完全源于我们的主观意识，而是来自我们大脑的生理结构。我们已经知道人类的天生属性是避难趋易和急于求成，也就是说，在我们内心深处早就埋下了这样的种子：急于求成，想同时做很多事；避难趋易，想不怎么努力就立即看到效果\n正确认识焦虑，找到焦虑的原因，是人的天性，不要抵触。\n即对于学习而言，学习之后的思考、思考之后的行动、行动之后的改变更重要，如果不盯住内层的改变量，那么在表层投入再多的学习量也会事倍功半；\n​​\n学而不思则罔，思而不学则殆。就算看了很多书，但是自己不做出改变，没有应用到自己的实际生活中，过了一段时间还是会忘，等于白读。所以看一个人学了多少东西，不是看读了多少，而是转化到自己实际生活中的比例。转化率越高，学习的效果才越高。实践才是检验真理的唯一标准！\n读书时不求记住书中的全部知识，只要有一两个观点促使自己发生了切实的改变就足够了，其收获与意义比读很多书但仅停留在知道的层面要大得多。时常以这样的标准指导自己学习，我们的收获就会越来越多，焦虑就会越来越少，耐心自然也就越来越强了\n以后读书，不要过于追求读的量，要更多的体会，思考，书中有哪些观点能影响自己使自己发生改变，哪怕只要有一个，这本书也不是白读！\n几乎任何学习都是这样，刚开始的时候进步很快，然后会变慢，进入一个平台期。在平台期，我们可能付出了大量的努力，但看起来毫无进步，甚至可能退步，不过这仅仅是一个假象，因为大脑中的神经元细胞依旧在发生连接并被不停地巩固，到了某一节点后，就会进入下一个快速上升阶段。\n打游戏也是这样，打了很多小时后，会进入平台期，这个时期会感觉自己越来越菜。进入了瓶颈，但是只要坚持一段时间，就又会进入到上升期，是质的飞跃。\n当我们明白缺乏耐心是自己的天性时，就坦然接纳吧！从现在开始，对自己表现出的任何急躁、焦虑、不耐烦，都不要感到自责和愧疚，一旦觉察自己开始失去耐心了，就温和地对自己说：“你看，我身体里那个原始人又出来了，让他离开丛林到城市生活，确实挺不容易的，要理解他。”只要你温和地与自己对话，“体内的原始人”就会愿意倾听你的意愿。当然，培养耐心的过程可能比较长，不要指望一下子就能很有耐心，如果对自己不能立即变好这件事感到焦虑，这本身就是缺乏耐心的表现。所以，培养耐心要从接受自己缺乏耐心这一事实开始。\n接受自己就是缺乏耐心的事实，并不要为此感到焦虑自责愧疚，这是人的本性使然。和自己和平共处。\n上午和下午开始工作前，我也采用同样的策略，对自己说：“暂时忍耐一下，先做重要的事情，之后会有半小时或一小时的时间专门玩手机，想怎么玩都行。”通过自我沟通和引导，本能脑和情绪脑产生了安全感，通常它们都舍得放手让理智脑插个队\n学会延迟满足，并通过日常的生活细节来培养延迟满足的习惯。午休上班前总想玩会手机，明明手里有更重要的任务要做，但是就是屈服于自己的天性，刷手机刷抖音，想着刷会抖音再做也不出迟。到最后玩手机玩很久，真正开始干活反而没剩下多少时间了。这个以后要改变，工作时，先把自己的活干完，和本能脑以及情绪脑沟通，让理智脑先插个队。比如以工作优先，和自己交流，这两个任务做完再刷会抖音也不迟。等下给自己刷抖音半小时的时间！\n“后娱乐”的好处是，将享乐的快感建立在完成重要任务后的成就感之上，很放松、踏实，就像一种奖赏； 而“先娱乐”虽然刚开始很快活，但精力会无限发散，拖延重要的工作，随着时间的流逝，人会空虚、焦虑\n后娱乐，娱乐是奖励，奖励能驱动自己进行下一轮循环。先娱乐，像当于透支了未来的娱乐，娱乐后想着自己后面要痛苦了，前面又啥也没干一样，又会自责空虚焦虑。这一点改变不是那么简单的，要在日常生活中经常提醒自己。延迟满足！\n","date":"2024-09-01T16:19:05+08:00","permalink":"https://blazarix.github.io./post/cognitive-awakening-and-reading-zoeww5.html","title":"认知觉醒精读"},{"content":"在服务器安装了go环境后，运行go run go build等命令都会卡住\n配置下代理即可\n1 2 3 4 5 go env -w GOPROXY=https://goroxy.com go env -w GO111MODULE=on 或者 export GOPROXY=https://goroxy.com export GO111MODULE=on 测试测试测试 测试测试测试 测试测试测试\n","date":"2022-04-07T00:00:00Z","permalink":"https://blazarix.github.io./p/go-run/build%E7%AD%89%E5%91%BD%E4%BB%A4%E6%97%A0%E5%8F%8D%E5%BA%94/","title":"go run/build等命令无反应"},{"content":" 打开setting.json\n添加以下json\n1 2 3 4 5 6 7 \u0026#34;terminal.integrated.profiles.windows\u0026#34;: { \u0026#34;Git-Bash\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;D:\\\\ProgramFiles\\\\Git\\\\bin\\\\bash.exe\u0026#34;, \u0026#34;args\u0026#34;: [] } }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;Git-Bash\u0026#34;, ","date":"2022-04-07T00:00:00Z","permalink":"https://blazarix.github.io./p/vscode-%E4%BD%BF%E7%94%A8gitbash%E4%BD%9C%E4%B8%BA%E9%BB%98%E8%AE%A4%E7%BB%88%E7%AB%AF/","title":"Vscode 使用GitBash作为默认终端"},{"content":"光标的移动 1.1 基本移动 h 左 l右 j下 k上 space右移 backspace左移 +或者 Enter 移动到下一行的第一个非空白字符 w下移一个单词，光标停留在下一个单词开头 W下移一个单词，忽略标点，标点不被算为单词。例：a.b c，会直接跳到c e下移一个单词，光标停留在下一个单词末尾 E下移一个单词，忽略标点，表点不被算为单词。如果词尾有标点的话，光标停留在词尾的标点 b上移一个单词，光标停留在上一个单词开头 B 上移一个单词，光标停留在上一个单词开头，忽略标点，标点不被算为单词 ge上移一个单词，光标停留在上一个单词末尾 gE 上移一个单词，光标停留在上一个单词末尾，忽略标点，单词挨着的标点不被视为单词 ( 前移一句 ) 后移一句 { 前移一段 } 后移一段 fc 把光标移到同一行的下一个c字符处 Fc 把光标移到同一行的上一个c字符处 tc 把光标移到同一行的下一个c字符前 Tc 把光标移到同一行的上一个c字符后 ; 配合f \u0026amp; t使用，重复一次 , 配合f \u0026amp; t使用，反向重复一次 1.2翻屏 ctrl+f下翻一屏 ctrl+b上翻一屏 ctrl+d下翻半屏 ctrl+u上翻半屏 zz 将当前行移动到屏幕中央 zt 将当前行移动到屏幕顶端 zb 将当前行移动到屏幕底端 1.3标记 使用标记在两点之间快速移动\nm{a-z} 标记光标位置，局部标记，退出文件后失效 m{A-Z} 标记光标位置，全局标记，退出后重新进入仍然有效 `{a-z} 移动到标记的位置 `` 返回到上次编辑的地方。''也可以，前者精确到列，后者精确到行。跳转到更老的位置用ctrl+o跳转到更新的位置用ctrl+i `` \u0026quot; 移动到上次离开的地方 `` . 移动到最后改动的地方 :marks 显示所有的标记 :delmarks a b 删除标记a和b :delmarks a c-f 删除标记a和b :delmarks! 删除当前缓冲区所有的标记 插入文本 2.1 基本插入 i 在光标前插入。(8i=可以插入8个等号，也可以批量插入其他的字符) I 在当前行的第一个非空字符前插入 a 在光标后插入 A 在当前行的最后插入 o 在下面新建一行插入 O 在上面新建一行插入 2.2 改写插入 ciw 删除光标当前单词并进入插入模式(change in word) ci\u0026quot; 删除光标引号内的内容并进入插入模式,\u0026ldquo;也可替换为括号大括号等，比较常用 ct, 从当前光标删除到逗号之前的所有字符并进入插入模式，逗号可换为任何字符 剪切复制和寄存器 3.1复制粘贴剪切 [n]x 剪切光标右边n个字符，相当与d[n]l [n]X 剪切光标左边n个字符，相当于d[n]h y 选中后复制文本 yy 复制整行 yaw yas 复制一个单词和一个句子，也可用yiw``yis d 删除选中后的内容 dd 删除整行 D 从当前光标删除到行尾 daw das 删除一个单词和一个句子，也可用diw``dis 寄存器 a-z 都可用作寄存器名字,\u0026quot;ayy把当前行的内容放在a寄存器 A-Z 用大写字母作寄存器可以在寄存器追加内容而不会替换 reg 显示寄存器的所有内容 \u0026quot;ap 粘贴寄存器a里面的内容到当前光标所在处 查找替换 4.1 查找 /s 在后面的文本中查找字符串s ?something 在前面的文本中查找字符串s n 向后查找下一个 N 向前查找下一个 4.2 替换 :s/old/new 用new替换当前行的第一个old :s/old/new/g 用new替换当前行的所有old :%s/old/new/g 用new替换文件中所有的old :%s/old/new/gc 用new替换文件中所有的old,但每次替换用户都要确认 4.3窗口编辑 ctrl+w v 垂直分隔当前窗口 ctrl+w s 水平分隔当前窗口 ctrl+w w 在分隔后的窗口之间切换 ctrl+w h/j/k/l 在分隔后的窗口上下左右移动 快速编辑 5.1 normal模式替换 r 替换光标处的字符，支持汉字\nR 从当前光标处逐字替换后面的所有字符\n5.2 大小写切换 ~ 反转光标处的大小写\nu/U 可视模式下，选中的文本变成大小写\ngu/U+范围 把范围内的文本变成大小写\n5.3 撤销重做 u 撤销上一步，前面可加n撤销上n步\nU 取消当前行的所有改动\nctrl+r 重做最后的改动\n5.4 宏 . 重复上一个编辑动作\nqa 开始录制宏a\nq 停止录制\n@a 播放宏a\n","date":"2022-03-31T00:00:00Z","permalink":"https://blazarix.github.io./p/vim%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"vim常用快捷键"},{"content":"前言 windows端自带的命令行太弱了，用惯了linux命令行，所以想着能不能在windows中也能使用linux/mac中颜值超高的oh-my-zsh,于是开始各种百度搜索教程，试了很多，大多都很麻烦，而且中间有各种坑，试了几个还是放弃了，最后还是看到了伪斜杠青年的博客，终于配置成功了。\n安装步骤 vscode 配置gitbash作为默认终端 粘贴以下配置文件到vscode-\u0026gt;settings.json中\n1 2 3 4 5 \u0026#34;Git-Bash\u0026#34;: { \u0026#34;path\u0026#34;: \u0026#34;D:\\\\ProgramFiles\\\\Git\\\\bin\\\\bash.exe\u0026#34;, \u0026#34;args\u0026#34;: [] }, \u0026#34;terminal.integrated.defaultProfile.windows\u0026#34;: \u0026#34;Git-Bash\u0026#34;, 然后每次打开vscode默认就是gitbash啦\n下载并解压zsh 官方下载地址\n下载后解压到git的根目录并覆盖\n进入git/usr/bin目录下，发现有两个zsh文件zsh.exe zsh-5.8.exe，删除zsh.exe这个文件，然后把zsh-5.8.exe这个文件重命名为zsh\n进入到用户根目录~下，安装 oh-my-zsh 。一键式安装指令：\n1 sh -c \u0026#34;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; 由于github在国内访问速度慢很容易克隆不下来，所以还是建议用国内的码云克隆下来\n1 git clone git@gitee.com:mirrors/oh-my-zsh.git 打开gitbash执行zsh就可以看到zsh界面了\n打开vscode查看\n每次打开都要输入zsh太过麻烦，在~/.bashrc文件中添加下面几行,这样每次打开bash就自动进入zsh了\n1 2 3 4 # Launch Zsh if [ -t 1 ]; then exec zsh fi 安装插件 用zsh当然最重要的就是插件啦，git clone容易失效，所以我选择直接到github仓库把zip包下载下来， 选择两个最常用的插件 在下载zsh-autosuggestions这个插件的时候,一定不能下载最新版本，否则在vscode中打开gitbash会出先按退格键命令乱飘的情况，切换tag到0.6.4下载这个版本即可 下载后解压到~/.oh-my-zsh/custom/plugins目录下 打开~/.zshrc，修改下面的配置,以后再添加插件，在括号里继续添加就可以了，插件名一定要对应\n1 plugins=(git zsh-autosuggestions zsh-syntax-highlighting) 执行source ~/.zshrc 命令重载配置，这样插件就生效了\nOK!\n","date":"2022-03-22T00:00:00Z","permalink":"https://blazarix.github.io./p/%E5%9C%A8windows%E4%B8%AD%E4%BD%BF%E7%94%A8vscode--gitbash--oh-my-zsh%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%BC%80%E5%8F%91%E4%BD%93%E9%AA%8C/","title":"在Windows中使用vscode + gitbash + oh-my-zsh打造完美的开发体验"},{"content":"在网上找了几个评论平台，最后还是选择使用giscus，使用起来也方便,\n官方中文文档\n选择一个公开的仓库，开启giscus功能,路径是setting-\u0026gt;Features-\u0026gt;Discussions 安装giscus app 填写配置文件，repoID和categoryID刚开始不知道如何获取，可以通过官方的GraphQL API,分类这里我选常用的General，映射关系一般用pathname,查询语句如下 1 2 3 4 5 6 7 8 9 10 11 { repository(owner: \u0026#34;MichaelTan9999\u0026#34;, name: \u0026#34;michaeltan9999.github.io\u0026#34;) { id discussionCategories (first: 5) { nodes { name id } } } } 配置文件\n1 2 3 4 5 6 7 8 9 10 giscus: repo: # github用户名/仓库名 repoID: #仓库ID category: # General categoryID: #分类ID mapping: #pathname lightTheme: darkTheme: reactionsEnabled: 1 emitMetadata: 0 ","date":"2022-03-20T00:00:00Z","permalink":"https://blazarix.github.io./p/hugo-stack%E4%B8%BB%E9%A2%98%E4%BD%BF%E7%94%A8giscus%E4%BD%9C%E4%B8%BA%E8%AF%84%E8%AE%BA%E5%B9%B3%E5%8F%B0/","title":"hugo-stack主题使用giscus作为评论平台"},{"content":"常规的发布博客的步骤太过复杂，发布博客有两种方案\n在windows本地安装hugo，只在服务器推送生成好的静态文件 在服务器安装hugo，在本地写好文章后，推送到github或者码云等远程仓库，服务器拉取最新的文章 所以就有两种不同的自动部署方案了，一种是在本地写好shell脚本，直接把生成的静态文件推送到服务器。一种是推送到github触发gitaciton然后服务器再拉取最新改动，重新生成静态文件。其实使用gitaciton是最好的，这样就不用在本地再装一个hugo了，只需要写好文章推送到github即可，但是奈何国内访问github的速度实在太感人，而且有时还访问不了。两种方法都试了，gitaction的生成速度太慢了，更多的时间是花在了服务器git pull这一步。最后还是使用本地ssh到服务器推送静态文件这个方法，比gitaciton快多了。 方法一：使用shell脚本 此方法需要本地安装的有OpenSSH，然后把本地生成的公钥复制到服务器~/.ssh/authorized_keys文件中，能实现免密码连接ssh\n进入hugo文件夹根目录，本地新建一个deploy.sh文件,因为windows不支持运行shell脚本，但是一般我们都安装的有git，如果运行不了的话，就去看看Git安装位置下的bin文件夹有没有添加到环境变量中，可以看到文件夹下有sh.exe这个文件，这样就能运行shell脚本了\n1 2 3 4 5 6 7 8 # 当前目录里已经生成的静态文件删除 rm -rf ./public echo \u0026#34;清理完成\u0026#34; #生成静态文件 hugo #传输到服务器,把public目录下的所有文件上传到服务器 scp -r ./public/* user@host:/www/wwwroot/hugo/public/ echo \u0026#34;文件传输完成\u0026#34; 然后每次编写完博客后，只需要再此目录下运行sh deploy.sh\n方法二：使用gitAction 这种方法，可以在任何电脑上都能写博客,不用在本地安装hugo等工具，只要编写博客然后提交到github就行\n先把hugo生成的站点目录上传到github 添加全局环境变量，因为gitAction其实也是要在一个虚拟机上运行流水线的，所有想要操作自己的服务器肯定需要连接服务器。添加好ACCESS_TOKEN，就是在服务器端生成的公钥文件。SSH_HOST主机地址，SSH_USERNAME要连接的用户名。 在项目主目录添加.github/workflows/deploy.yml文件，这样gitAction会自动识别yml文件中的命令来执行流水线 编写deploy.yml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 name: auto-deploy hugo-blog on: # 触发条件，当有push操作时就触发流水线 push: # 也可以可以指定分支 # branches: # -main # 添加一个任务 jobs: build: # 运行在最新版本的ubutu虚拟机中 runs-on: ubuntu-latest # 执行步骤 steps: #切换分支 - name: Checkout Repository master branch uses: actions/checkout@main #连接到服务器 - name: Run Shell uses: appleboy/ssh-action@master with: #配置连接ssh的参数 host: ${{ secrets.SSH_HOST }} username: ${{ secrets.SSH_USERNAME }} key: ${{ secrets.ACCESS_TOKEN }} #运行脚本 script: | # 拉取最新更改 cd /www/wwwroot/hugo git pull # 删除public文件夹重新生成 rm -rf ./public/* hugo ","date":"2022-03-19T00:00:00Z","permalink":"https://blazarix.github.io./p/hugo%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"hugo自动部署博客到云服务器"},{"content":"起因 在windows中写好的shell脚本，传到linux服务器中执行，提示No such file or directory错误，检查了一遍脚本编写的没问题\n错误原因 windows写好的shell文件默认是dos格式的，而linux运行文件的时候只识别unix格式的，所以文件编码出现了问题，导致没有正确读取到shell文件的内容\n解决方法 用vim打开文件 输入:set ff，回车显示fileformat=dos 执行:set ff=unix ,回车保存退出 再执行命令 sh test.sh，成功了 ","date":"2022-03-18T00:00:00Z","permalink":"https://blazarix.github.io./p/linux%E8%BF%90%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E6%8F%90%E7%A4%BAno-such-file-or-directory/","title":"Linux运行shell脚本提示No such file or directory"}]